@;add a statement to any file saying that it's autogenerated
"% this file is autogenerated. DO NOT EDIT!!!"

@(require racket/string racket/system racket/port)
@(define course-dir (getenv "COURSE_DIR"))
@(define course-number (getenv "COURSE_NUM"))
@(define course-name (getenv "COURSE_NAME"))
@(define notes-dir (format "~a/content/notes" course-dir))
@(define problems-dir (format "~a/content/Problems" course-dir))
@(define professor-top (getenv "COURSE_PROF"))
@(define shaded-modes (map string->symbol (string-split (or (getenv "SHADED_MODES") ""))))
@(define all-modes (append modes (map string->symbol (string-split (or (getenv "DEFAULT_MODES") "")))))
%%;;

%% Define course references
@(define course-sem-one (or (getenv "COURSE_SEM_ONE") course-number))
@(define course-sem-two (or (getenv "COURSE_SEM_TWO") course-number))
@(define course-other (or (getenv "COURSE_OTHER") course-number))
@(define course-advanced (or (getenv "COURSE_ADVANCED") course-number))
@defcommand{nameSemBoth}{}{CS @course-sem-one / @course-sem-two}
@defcommand{nameSemOne}{}{CS @course-sem-one}
@defcommand{nameSemTwo}{}{CS @course-sem-two}
@defcommand{nameSemOther}{}{CS @course-other}
@defcommand{nameSemAdvanced}{}{CS @course-advanced}

@(define (lecnotes) (define name (get-arg))
(values 
  (add-to-input "% rubber: path " notes-dir "/" name "\n")
  (add-to-input "% rubber: depend " notes-dir "/" name "/notes.tex\n")
  (include (build-path notes-dir name "notes.tex"))))

@(define (prob) (define name (get-arg))
(values
  (add-to-input "% rubber: path " problems-dir "/" name "\n")
  (add-to-input "% rubber: depend " problems-dir "/" name "/prob.tex\n")
  (include (build-path problems-dir name "prob.tex"))))

@(define (localnotes) (define name (get-arg))
(values
  #;(add-to-input "% rubber: depend " name ".tex\n")
  (include (string-append name ".tex"))))

@(define (include+depend) (define name (get-arg))
(values
  (add-to-input "% rubber: depend " name "\n")
  (include name)))

@defcommand{asgnname}{x}{\newcommand{\asgnname}{x}}
@defcommand{dateprefix}{pfx}{\newcommand{\dateprefix}{pfx}}

\documentclass{courseclass}
\usepackage{etex}
\usepackage{multirow}
\usepackage{slatex}
\usepackage{parsetree}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{course}
\usepackage[nounderscore]{syntax}
\usepackage{bbold}
\usepackage[all]{xy}
\usepackage{color}
\usepackage{mathsymb}
\usepackage{enumerate}
\usepackage{timestamp}
\usepackage{fancyvrb}
\usepackage{microtype}
\usepackage{listings}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{graphs}
\usepackage{tikz,pgfplots}
\lstdefinelanguage{scala}{}

\input{pygments_support.tex}

@cs{coursedates}

@defcommand{missive}{}{@asgnname{CS@course-number Course Missive}
@coursedate{missive}@dateprefix{}}

@defcommand{lec}{^num ^name}{@asgnname{Lecture ^num: ^name}
@coursedate{lec^num}@dateprefix{}}

@defcommand{topic}{^num ^name}{@asgnname{Topic ^num: ^name}
@coursedate{lec^num}@dateprefix{}}

@defcommand{lab}{^num ^name}{@asgnname{Lab ^num: ^name}
@coursedate{lab^num}@dateprefix{}}

@defcommand{helpsession}{^name}{@asgnname{Help Session: ^name}
@coursedate{helpsession^name}@dateprefix{}}

@defcommand{reviewsession}{^num ^name}{@asgnname{Review Session ^num: ^name}
@coursedate{reviewsession^name}@dateprefix{}}

@defcommand{workshop}{^num ^name}{@asgnname{Workshop ^num: ^name}
@coursedate{workshop^num}@dateprefix{}}

@defcommand{checkpoint}{}{
\begin{addition}
You've reached a checkpoint!  Please call over a lab TA to review your work.
\end{addition}
}

@defcommand{endoflab}{}{
\begin{addition}
Once a lab TA signs off on your work, you've finished the lab! 
Congratulations!  Before you leave, make sure both partners have
access to the code you've just written.
\end{addition}
}

@defcommand{proj}{^num ^name}{@asgnname{Project ^num: ^name}
@coursedate{proj^num}@dateprefix{Due: }
\renewcommand{\labelenumi}{\alph{enumi}.} % ???

@defcommand{prelimdate}{}{@printdate{proj^num-prelim}}
@defcommand{finaldate}{}{@printdate{proj^num}}
}

@defcommand{exam}{^num ^name}{@asgnname{Exam ^num: ^name}
@coursedate{exam^num}@dateprefix{Due: }
\renewcommand{\labelenumi}{\alph{enumi}.} % ???
@defcommand{duedate}{}{@printdate{exam^num}}
}

@defcommand{hw}{^num ^name}{@asgnname{Homework ^num: ^name}
@coursedate{hw^num}@dateprefix{Due: }
\renewcommand{\labelenumi}{\arabic{enumi}.}

@defcommand{practice}{}{
\section*{Practice}}

@defcommand{problems}{}{
\section*{Problems}}

@defcommand{extracredit}{}{
\section*{Extra Credit}}
}

@defcommand{hw*}{^num}{@asgnname{Homework ^num}
@coursedate{hw^num}@dateprefix{Due: }
\renewcommand{\labelenumi}{\arabic{enumi}.}

@defcommand{practice}{}{
\section*{Practice}}

@defcommand{problems}{}{
\section*{Problems}}

@defcommand{extracredit}{}{
\section*{Extra Credit}}
}

@defcommand{doc}{^name ^date}{@asgnname{^name}
\DeclareRobustCommand{\CSduedate}{^date}@dateprefix{}}

@defcommand{coursedate}{^datesym}{\DeclareRobustCommand{\CSduedate}{@printdate{^datesym}}}

@defcommand{ignore}{body}{}
@defcommand{error}{body}{}

@(define (version)
   (define vername (string->symbol (get-arg)))
   (define body (get-arg))
   (let ([is-shaded (member vername shaded-modes)])
        (if (member vername all-modes)
         (list 
               (if is-shaded "\\begin{shaded}" "")
               body
               (if is-shaded "\\end{shaded}" "")
               )
         (list))))

\definecolor{shadecolor}{gray}{0.90}

\DeclareRobustCommand{\CSclassnum}{\textbf{CS@course-number}}
\DeclareRobustCommand{\CSclassname}{@course-name}
\DeclareRobustCommand{\CSprof}{@professor-top}

@defcommand{TODO}{^arg}{{\LARGE\bf ^arg}} % style for noting things needing fixing
@defcommand{alternate}{^arg}{\textbf{Alternate Solution (^arg):} }
@defcommand{summary}{}{{\bf Summary:} }
@defcommand{answer}{}{{\bf Answer:} }
@defcommand{asgn}{}{{\bf Assignment:} }
@defcommand{short}{}{{\bf Short Answer:} }
@defcommand{long}{}{{\bf Long Answer:} }
@defcommand{notation}{}{{\bf Notation:} }
@defcommand{theorem}{}{{\bf Theorem:} }
@defcommand{lemma}{}{{\bf Lemma:} }
@defcommand{observation}{}{{\bf Observation:} }
@defcommand{proposition}{}{{\bf Proposition:} }
@defcommand{corollary}{}{{\bf Corollary:} }
@defcommand{definition}{}{{\bf Definition:} }
@defcommand{def}{}{{\bf Definition:} }
@defcommand{desc}{}{{\bf Description:} }
@defcommand{example}{}{{\bf Example:} }
@defcommand{exercise}{}{{\bf Exercise:} }
@defcommand{extra}{}{{\bf Extra Credit:} }
@defcommand{fun}{}{{\bf Just for Fun:} }
@defcommand{warning}{}{{\bf Warning:} }
@defcommand{remark}{}{\textbf{Remark:} }
@defcommand{claim}{}{\textbf{Claim:} }
@defcommand{claim1}{}{\textbf{Claim 1:} }
@defcommand{claim2}{}{\textbf{Claim 2:} }
@defcommand{claim1prime}{}{\textbf{Claim 1$'$:} }
@defcommand{claim2prime}{}{\textbf{Claim 2$'$:} }
@defcommand{alt-proof}{}{\textbf{Alternate Proof:} }
@defcommand{proof}{}{\textbf{Proof:} }
@defcommand{basis}{}{\textbf{Basis:} }
@defcommand{step}{}{\textbf{Step:} }
@defcommand{tip}{}{\textbf{Tip:} }
@defcommand{hint}{}{\textbf{Hint:} }
@defcommand{caveat}{}{\textbf{Caveat:} }
@defcommand{intro}{}{\textbf{Introduction} \\}
@defcommand{majerrs}{}{\textbf{Major errors:} }
@defcommand{minerrs}{}{\textbf{Minor errors:} }
@defcommand{mydef}{^arg}{{\bf ^arg}}
@defcommand{note}{}{\textbf{Note:} }
@defcommand{alg}{}{\textbf{Algorithm:} }
@defcommand{objectives}{}{\textbf{Objectives:} }
@defcommand{pct}{}{\texttt{\%}}
@defcommand{question}{}{{\bf Question:     }}
@defcommand{quiz}{}{\textbf{Quiz:} }
@defcommand{remark}{}{\textbf{Remark:} }
@defcommand{rubric}{}{\textbf{Rubric:} }
@defcommand{solution}{}{\textbf{Solution:} }
@defcommand{steps}{}{\textbf{Steps:} }
@defcommand{task}{}{\textbf{Task:} }
@defcommand{warning}{}{{\bf Warning:} }
@defcommand{reminder}{}{{\bf Reminder:} }

@defcommand{lec01}{}{{Lecture 1}}
@defcommand{lec02}{}{{Lecture 2}}
@defcommand{lec03}{}{{Lecture 3}}
@defcommand{lec04}{}{{Lecture 4}}
@defcommand{lec05}{}{{Lecture 5}}
@defcommand{lec06}{}{{Lecture 6}}
@defcommand{lec07}{}{{Lecture 7}}
@defcommand{lec08}{}{{Lecture 8}}
@defcommand{lec09}{}{{Lecture 9}}
@defcommand{lec10}{}{{Lecture 10}}
@defcommand{lec11}{}{{Lecture 11}}
@defcommand{lec12}{}{{Lecture 12}}

@defcommand{lab01}{}{{Lab 1}}
@defcommand{lab02}{}{{Lab 2}}
@defcommand{lab03}{}{{Lab 3}}
@defcommand{lab04}{}{{Lab 4}}
@defcommand{lab05}{}{{Lab 5}}
@defcommand{lab06}{}{{Lab 6}}
@defcommand{lab07}{}{{Lab 7}}
@defcommand{lab08}{}{{Lab 8}}
@defcommand{lab09}{}{{Lab 9}}
@defcommand{lab10}{}{{Lab 10}}
@defcommand{lab11}{}{{Lab 11}}
@defcommand{lab12}{}{{Lab 12}}

@defcommand{hw01}{}{{Homework 1}}
@defcommand{hw02}{}{{Homework 2}}
@defcommand{hw03}{}{{Homework 3}}
@defcommand{hw04}{}{{Homework 4}}
@defcommand{hw05}{}{{Homework 5}}
@defcommand{hw06}{}{{Homework 6}}
@defcommand{hw07}{}{{Homework 7}}
@defcommand{hw08}{}{{Homework 8}}
@defcommand{hw09}{}{{Homework 9}}
@defcommand{hw010}{}{{Homework 10}}
@defcommand{hw011}{}{{Homework 11}}
@defcommand{hw012}{}{{Homework 12}}

% Point counts:
% {\DeclareRobustCommand{\CSpointcount}{\small (#1 pts.)}}

\newlength{\CSclassnumwidth}
\settowidth{\CSclassnumwidth}{\CSclassnum}
\DeclareRobustCommand{\CSduedate}{TBA}

@defcommand{oopslatexstart}{}{\setkeyword{
    
    abstract    continue    for new switch
    assert   default goto   package synchronized
    boolean do  if  private this null
    break   double  implements  protected   throw
    byte    else    import  public  throws
    case    enum    instanceof  return  transient
    catch   extends int short   param try
    char    final   interface   static  void
    class   finally long    strictfp  volatile
    const  float   native  super   while

    Scala keywords
    Boolean Char Byte Short Int Long Float Double Unit Null Nothing
    abstract do finally import object requires throw val
    case    catch   class   def else    extends false   final for   forSome if
    implicit lazy   match   new null override   package private protected return
    sealed  super   this trait  try true    type var    while   with    yield

    ;
  
}}

@defcommand{oopslatexend}{}{\setvariable{
    
    abstract    continue    for new switch
    assert***   default goto*   package synchronized
    boolean do  if  private this
    break   double  implements  protected   throw
    byte    else    import  public  throws
    case    enum****    instanceof  return  transient
    catch   extends int short   try
    char    final   interface   static  void
    class   finally long    strictfp**  volatile
    const*  float   native  super   while

    Scala keywords 
    abstract do finally import object requires throw val
    case    catch   class   def else    extends false   final for   forSome if
    implicit lazy   match   new null override   package private protected return
    sealed  super   this trait  try true    type var    while   with    yield
}}

@defcommand{oopdisplay}{^text}{@scala{^text}}
@defcommand{oop}{^text}{@oopslatexstart{}\scheme{^text}@oopslatexend{}}
@defcommand{oopcode}{^text}{@code{scala}{^text}}
@(define (pygmentize . args)
    (apply subprocess (append `(#f #f #f ,(find-executable-path "pygmentize")) args)))
@(define (code)
    (let ([lang (get-arg)] [text (get-arg*)])
        (let-values ([(proc stdout stdin stderr) (pygmentize "-f" "latex" "-l" lang)])
            (display text stdin)
            (flush-output stdin)
            (close-output-port stdin)
            (string-replace (port->string stdout) "@" "@@"))))
@defcommand{codeinline}{^lang ^text}{\begingroup\RecustomVerbatimEnvironment{Verbatim}{BVerbatim}{}@code{^lang}{^text}\endgroup@(if (regexp-try-match #rx"^[ \t\r\n]" (stdin)) "~" " ")}
@(define (includecode/lang)
    (let ([lang (get-arg)] [filename (get-arg)])
        (let-values ([(proc stdout stdin stderr) (pygmentize "-f" "latex" "-l" lang filename)])
            (string-replace (port->string stdout) "@" "@@"))))
@(define (includecode)
    (let ( [filename (get-arg)])
        (let-values ([(proc stdout stdin stderr) (pygmentize "-f" "latex" filename)])
            (string-replace (port->string stdout) "@" "@@"))))
% include a java or scala file with the package declaration removed
@(define (package-trim)
  (let ([input-port (open-input-file (get-arg))])
    (string-trim
      (string-replace (port->string input-port) "@" "@@")
      #px"package (.*?)(\n)[\\s]*(?=[^\\s])|[\\s]*")))
%% Java Definitions
@defcommand{java}{^text}{@code{java}{^text}}
@defcommand{javainclude}{^file}{@includecode/lang{java}{^file}}
@defcommand{javainline}{^text}{@codeinline{java}{^text}}
@defcommand{javasolution}{^name}{@version{sol}{@includecode/lang{java}{^name}}}
@defcommand{javaapi}{^text}{\href{http://docs.oracle.com/javase/7/docs/api/^text.html}{^text}}
@version{java} {
  @defcommand{langnotes}{^path}{
    @localnotes{java/^path}
  }
  @defcommand{langsol}{^path}{
    @version{sol}{@java{@package-trim{java/^path.java}}}
  }
  @defcommand{langsrc}{^path}{
    @java{@package-trim{java/^path.java}}
  }
}
%% Scala Definitions
@defcommand{scala}{^text}{@code{scala}{^text}}
@defcommand{scalainline}{^text}{@codeinline{scala}{^text}}
@defcommand{scalainclude}{^file}{@includecode/lang{scala}{^file}}
@defcommand{scalasolution}{^name}{@version{sol}{@includecode/lang{scala}{^name}}}
@version{scala} {
  @defcommand{langnotes}{^path}{
    @localnotes{scala/^path}
  }
  @defcommand{langsol}{^path}{
    @version{sol}{@scala{@package-trim{scala/^path.scala}}}
  }
  @defcommand{langsrc}{^path}{
    @scala{@package-trim{scala/^path.scala}}
  }
}
%% Scheme Definitions
@defcommand{scheme}{^text}{@code{scheme}{^text}}
@defcommand{schemedisplay}{^text}{@env{schemedisplay}{^text}}
@defcommand{schemeinline}{^text}{@codeinline{scheme}{^text}}
@defcommand{schemesolution}{^name}{@version{sol}{@includecode/lang{scheme}{^name}}}
@defcommand{schemeinclude}{^file}{@includecode/lang{scheme}{^file}}
%% OCaml Definitions
@defcommand{ocaml}{^text}{@code{ocaml}{^text}}
@defcommand{smallocaml}{^text}{@ocamlinline{^text}}
@defcommand{ocamlinline}{^text}{@codeinline{ocaml}{^text}}
@defcommand{ocamlslatexstart}{}{\setkeyword{exception fun match then try with in let module open rec type val :: end sig struct}}
@defcommand{ocamlslatexend}{}{\setvariable{exception fun match then try with in let module open rec type val :: end sig struct}}
@defcommand{ocamldisplay}{^text}{@ocamlslatexstart{}\begin{schemedisplay}^text\end{schemedisplay}@ocamlslatexend{}}
@defcommand{ocamlsolution}{^name}{@version{sol}{@includecode/lang{ocaml}{^name}}}
@defcommand{ocamlinclude}{^file}{@includecode/lang{ocaml}{^file}}
%% Shell Definitions
@defcommand{shell}{^text}{@code{bash}{^text}}
@defcommand{shellinline}{^text}{@codeinline{bash}{^text}}
@defcommand{shellinclude}{^file}{@includecode/lang{bash}{^file}}
@defcommand{shellsolution}{^name}{@version{sol}{\begin{lstlisting}
@include{^name}\end{lstlisting}}}
%% Golang Definitions
@defcommand{golang}{^text}{@code{go}{^text}}
@defcommand{golanginline}{^text}{@codeinline{go}{^text}}
@defcommand{golanginclude}{^file}{@includecode/lang{go}{^file}}
@defcommand{golangsolution}{^name}{@version{sol}{@includecode/lang{go}{^name}}}

@defcommand{href}{^site ^text}{\href{^site}{^text}\footnote{\url{^site}}}


@defcommand{env}{^envname ^body}{\begin{^envname}
^body
\end{^envname}}

@(define (repeat)
   (define (help n datum)
     (cond ((zero? n) '())
           (else (cons datum (help (sub1 n) datum)))))
   (help (string->number (get-arg)) (get-arg)))

% vim: ft=tex

